package cryptography

/*
   Sliver Implant Framework
   Copyright (C) 2019  Bishop Fox

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

import (
	"crypto/tls"
	"crypto/x509"
	"strings"

	"github.com/bishopfox/sliver/protobuf/sliverpb"
	"github.com/bishopfox/sliver/server/certs"
	"github.com/bishopfox/sliver/server/db/models"
	"github.com/bishopfox/sliver/server/log"
)

var (
	mtlsLog = log.NamedLogger("cryptography", "tls")
)

// tlsConfig - A wrapper around several elements needed to produce a TLS config for either
// a server or a client, depending on the direction of the connection to the implant.
type tlsConfig struct {
	ca   *x509.CertPool
	cert tls.Certificate
	key  []byte
}

// TLSConfigFromProfile - Given a C2 profile needing TLS set up, this function
// loads either the certificates & keys it contains, or puts default ones into it.
func TLSConfigFromProfile(p *models.C2Profile) (creds *tls.Config) {

	// If certificates are in the profile, just use them without questions.
	// The caller is supposed to know what he does with profiles having custom certificates.
	if len(p.CACertPEM) > 0 || len(p.CertPEM) > 0 || len(p.KeyPEM) > 0 {
		// Depending on the direction, create the correct config
		switch p.Direction {
		case sliverpb.C2Direction_Bind:
			conf := newClientCredentialsTLS()
			creds = conf.ClientConfigFromCerts(p.CertPEM, p.KeyPEM)
		case sliverpb.C2Direction_Reverse:
			conf := newServerCredentialsTLS()
			creds = conf.ServerConfigFromCerts(p.CertPEM, p.KeyPEM)
		}
		return
	}

	// Else, use certificates simply matching the target host, and generated by
	// Sliver's internal certificate & key store. Use the appropriate hostname
	// base on the C2 Protocol used: HTTP Profiles have the notion of domains that MTLS don't.
	var hostname string
	switch p.Channel {
	case sliverpb.C2Channel_HTTPS:
		if len(strings.Split(p.Domains, ",")) == 0 {
			hostname = p.Hostname
		} else {
			hostname = strings.Split(p.Domains, ",")[0]
		}
	default:
		hostname = p.Hostname
	}

	switch p.Direction {
	case sliverpb.C2Direction_Bind:
		conf := newClientCredentialsTLS()
		creds = conf.ClientConfig(hostname)
	case sliverpb.C2Direction_Reverse:
		conf := newServerCredentialsTLS()
		creds = conf.ServerConfig(hostname)
	}

	return
}

// newCredentialsTLS - Generates a new custom tlsConfig loaded with the Slivers Certificate Authority.
// It may thus load and export any TLS configuration for talking with an implant, bind or reverse.
func newClientCredentialsTLS() (creds *tlsConfig) {

	// The Certificate Authority is needed by all TLS configs, whether server or client.
	sliverCACert, _, err := certs.GetCertificateAuthority(certs.MtlsServerCA)
	if err != nil {
		mtlsLog.Fatalf("Failed to find CA type (%s)", certs.MtlsServerCA)
	}
	sliverCACertPool := x509.NewCertPool()
	sliverCACertPool.AddCert(sliverCACert)

	creds = &tlsConfig{
		ca: sliverCACertPool,
	}

	return creds
}

// newCredentialsTLS - Generates a new custom tlsConfig loaded with the Slivers Certificate Authority.
// It may thus load and export any TLS configuration for talking with an implant, bind or reverse.
func newServerCredentialsTLS() (creds *tlsConfig) {

	// The Certificate Authority is needed by all TLS configs, whether server or client.
	sliverCACert, _, err := certs.GetCertificateAuthority(certs.MtlsImplantCA)
	if err != nil {
		mtlsLog.Fatalf("Failed to find CA type (%s)", certs.MtlsImplantCA)
	}
	sliverCACertPool := x509.NewCertPool()
	sliverCACertPool.AddCert(sliverCACert)

	creds = &tlsConfig{
		ca: sliverCACertPool,
	}

	return creds
}

// ClientConfigFromCerts - TLS configuration built with custom certificates, that is,
// not the default ImplantCA certificates that are automatically used with Channels like MTLS
func (t *tlsConfig) ClientConfigFromCerts(certPEM, keyPEM []byte) (c *tls.Config) {

	var err error
	t.cert, err = tls.X509KeyPair(certPEM, keyPEM)
	if err != nil {
		mtlsLog.Fatalf("Error loading server certificate: %v", err)
	}

	// Client config with custom certificate validation routine
	c = &tls.Config{
		Certificates:          []tls.Certificate{t.cert},
		RootCAs:               t.ca,
		InsecureSkipVerify:    true, // Don't worry I sorta know what I'm doing
		VerifyPeerCertificate: t.rootOnlyVerifyCertificate,
	}
	c.BuildNameToCertificate()

	return
}

// ClientConfig - TLS config used when we dial an implant over Mutual TLS.
// This makes use of a custom function for skipping (only) hostname validation,
// because the tlsConfig verifies the peer only against its own Certificate Authority.
func (t *tlsConfig) ClientConfig(host string) (c *tls.Config) {

	// The host is the address of the host on which the implant is listening.
	certPEM, keyPEM, err := certs.GetECCCertificate(certs.MtlsImplantCA, host)
	if err != nil {
		certs.MtlsC2ImplantGenerateECCCertificate(host)
	}
	certPEM, keyPEM, err = certs.GetECCCertificate(certs.MtlsImplantCA, host)
	if err != nil {
		mtlsLog.Errorf("Failed to generate or fetch certificate TWICE: %s", err)
		return nil
	}

	t.cert, err = tls.X509KeyPair(certPEM, keyPEM)
	if err != nil {
		mtlsLog.Fatalf("Error loading server certificate: %v", err)
	}

	// Client config with custom certificate validation routine
	c = &tls.Config{
		Certificates:          []tls.Certificate{t.cert},
		RootCAs:               t.ca,
		InsecureSkipVerify:    true, // Don't worry I sorta know what I'm doing
		VerifyPeerCertificate: t.rootOnlyVerifyCertificate,
	}
	c.BuildNameToCertificate()

	return c
}

// ServerConfigFromCerts - TLS configuration built with custom certificates, that is,
// not the default ImplantCA certificates that are automatically used with Channels like MTLS
func (t *tlsConfig) ServerConfigFromCerts(certPEM, keyPEM []byte) (c *tls.Config) {

	var err error
	t.cert, err = tls.X509KeyPair(certPEM, keyPEM)
	if err != nil {
		mtlsLog.Fatalf("Error loading server certificate: %v", err)
	}

	// Server configuration
	c = &tls.Config{
		RootCAs:      t.ca,
		ClientAuth:   tls.RequireAndVerifyClientCert,
		ClientCAs:    t.ca,
		Certificates: []tls.Certificate{t.cert},
		MinVersion:   tls.VersionTLS13,
	}
	c.BuildNameToCertificate()

	return
}

// ServerConfig - TLS config used when we listen for incoming Mutual TLS implant connections.
func (t *tlsConfig) ServerConfig(host string) (c *tls.Config) {

	// The host is either the server host, or a host on which an implant is listening.
	// If the host is one of an implant's, the server acts as if it ways this host.
	certPEM, keyPEM, err := certs.GetECCCertificate(certs.MtlsServerCA, host)
	if err != nil {
		certs.MtlsC2ServerGenerateECCCertificate(host)
	}
	certPEM, keyPEM, err = certs.GetECCCertificate(certs.MtlsServerCA, host)
	if err != nil {
		mtlsLog.Errorf("Failed to generate or fetch certificate TWICE: %s", err)
		return nil
	}

	t.cert, err = tls.X509KeyPair(certPEM, keyPEM)
	if err != nil {
		mtlsLog.Fatalf("Error loading server certificate: %v", err)
	}

	// Server configuration
	c = &tls.Config{
		RootCAs:      t.ca,
		ClientAuth:   tls.RequireAndVerifyClientCert,
		ClientCAs:    t.ca,
		Certificates: []tls.Certificate{t.cert},
		MinVersion:   tls.VersionTLS13,
	}
	c.BuildNameToCertificate()

	return
}

// rootOnlyVerifyCertificate - Go doesn't provide a method for only skipping hostname validation so
// we have to disable all of the fucking certificate validation and re-implement everything.
// https://github.com/golang/go/issues/21971
func (t *tlsConfig) rootOnlyVerifyCertificate(rawCerts [][]byte, _ [][]*x509.Certificate) error {

	cert, err := x509.ParseCertificate(rawCerts[0]) // We should only get one cert
	if err != nil {
		return err
	}

	// Basically we only care if the certificate was signed by our authority
	// Go selects sensible defaults for time and EKU, basically we're only
	// skipping the hostname check, I think?
	options := x509.VerifyOptions{
		Roots: t.ca,
	}
	if _, err := cert.Verify(options); err != nil {
		return err
	}

	return nil
}
