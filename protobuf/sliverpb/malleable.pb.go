// ------------------------------------------------------------------------------
//
// *** Overview ***
//
// This file contains all the C2 Malleable Profile definitions.
// These definitions might be accessed and edited by users wishing
// to write Malleable profiles, or simply used by commands spawning handlers,
// and by the implant generation code, when channels are compiled in the build.
//
// This data is in a different file so that we can treat its Go generated
// code separately, and automatically generate things like JSON schema files
// for completion/validation/documentation of the various C2 base/advanced options.

// *** Adding Channels ***
//
// The first strongly advised thing, for those who wish to either write a new Profile
// from scratch, or a completely new Channel stack, should open a Sliver console, use
// the `malleable new` or `malleable edit` command, and profit from JSON schema
// completion and documentation. This is useful to have an overview of what can be
// set within a Malleable profile, from top to bottom.

// Also, the directory containing all Sliver Protobuf definitions (including here)
// is managed and validated by the buf.build/buf tool, and its associated yaml files.
// Linting standards are particularly enforced on this file (comments, lengths,
// naming) because all of its contents will/might be exposed to user edition.
// All those fields have specific purposes and may have far-reaching consequences
// on the overall channel/implant functionality, and thus should be all correctly
// documented, and easily accessible via either the console, or from an editor.
// So...PLEASE CORRECTLY DOCUMENT EVERTYHING YOU ADD, AND ABIDE WITH LINTING RULES.
//
// Finally, you are free to add any message, enum or fields to this file, whether
// those are part of existing messages (you will need to if you add a new Channel)
// or entirely new ones.
//
// -------------------------------------------------------------------------------

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.26.0
// 	protoc        v3.18.1
// source: sliverpb/malleable.proto

package sliverpb

import (
	_ "github.com/srikrsna/protoc-gen-gotag/tagger"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// C2Type - The type of interaction that is enabled by the C2 profile.
// This, in other words, is the level of interactivity that you have
// over the implant. There are important differences between those types,
// and consequences on tooling availalibity can be significant, as it's
// the case for network discovery and pivoting tools that are possible
// through a Session channel, and not on a Beacon one.
type C2Type int32

const (
	// Session - The most basic C2 type, a session is interactive. This type
	// provides many advantages over beacon C2s, because one benefits from
	// all real-time completions for the host target environment and its
	// associated commands (Sliver commands, not host bins).
	// Sidenote: the Session type is also used internally by the Beacon type,
	// because a Session provides with the transport stack management code and
	// TLV read/write boilerplate around it. The beacon is very short-lived session.
	C2Type_Session C2Type = 0
	// Beacon - The Beacon type allows an implant to beacon out through its current
	// transport stack, which means establishing a connection, fetching any tasks to
	// execute from the server, perform them and send results back, then close the
	// connection stack.
	// This, by nature, is lesser interactive than the Session type. No networking
	// tools are available when interacting with a Beacon-channel implant, and other
	// commands/functionality making use of stream-like tunneling will be either
	// unavailable, or will be fetching the streamed data through other means.
	// (eg: some execution & injection commands that require a new payload as bytes.)
	// The beacon type is available with all C2 transport stacks, in any direction.
	C2Type_Beacon C2Type = 1 // Could be lower-level, like plain ReadWriteCloser ?
)

// Enum value maps for C2Type.
var (
	C2Type_name = map[int32]string{
		0: "Session",
		1: "Beacon",
	}
	C2Type_value = map[string]int32{
		"Session": 0,
		"Beacon":  1,
	}
)

func (x C2Type) Enum() *C2Type {
	p := new(C2Type)
	*p = x
	return p
}

func (x C2Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (C2Type) Descriptor() protoreflect.EnumDescriptor {
	return file_sliverpb_malleable_proto_enumTypes[0].Descriptor()
}

func (C2Type) Type() protoreflect.EnumType {
	return &file_sliverpb_malleable_proto_enumTypes[0]
}

func (x C2Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use C2Type.Descriptor instead.
func (C2Type) EnumDescriptor() ([]byte, []int) {
	return file_sliverpb_malleable_proto_rawDescGZIP(), []int{0}
}

// C2 - The global name of the networking stack used by this C2. Therefore, many
// kinds of names can be valid when you add yours; some channels will use the
// name of their transport protocols (TCP), their applications protocol
// (DNS/HTTPS) or even specifics about their security details (MTLS, for
// Mutually Authenticated TLS). Yet other Channels, like WireGuard, are also
// complete networking stacks of their own.
// Also, note that some protocols might or might not be unable to automatically
// route their listeners/dialers through Sliver's routing system (which works
// quite like Metasploit' Comm Subsystem, but without Routes as subnets).
type C2 int32

const (
	// TCP - The most simple transport stack in Sliver. This channel establishes
	// a TCP connection between two parties (either server-implant, or pivot-implant)
	// and hands over to the Channel driver for session/beacon action. To be noted:
	// Although there is no TLS encryption, the Channel core type (session/beacon)
	// DOES ENCRYPT all data sent on the wire with its own cryptosystem. Thus, the
	// connection is still deemed to be secure, but without any TLS handshake bust.
	// This channel is available for bind and reverse connections.
	C2_TCP C2 = 0
	// MTLS - A Mutually-Authenticated TLS encryption channel, in which both parties
	// will verify the authenticity and identity of their respective certificates.
	// More explanation on how this works in Sliver is available in the project Wiki.
	// This channel is available for bind and reverse connections.
	C2_MTLS C2 = 1
	// HTTP - The HTTP channel is different from the HTTPS channel the same way the
	// TCP channel is different from the MTLS one: No "system-level" TLS is set up,
	// so the identity of both parties is not enforced at the HTTP-level. Though,
	// like with TCP, the Channel core will encrypt all data passed on the wire.
	// This channel is only available for reverse connections.
	C2_HTTP C2 = 2
	// HTTPS - The HTTPS channel has several mode of TLS setup available.
	// For differences with the HTTP mode, please refer to the C2_HTTP type.
	// The TLS layer is here always set at the HTTP level, and can be either:
	// - Provided by a specialized LetsEncrypt server started along the C2 Handler.
	// - Mutually authenticated with the same TLS stack used by the MTLS Channel
	// Therefore, the way to set up the security details of your wish is to head to
	// the Credentials section of the profile, and perform any modifications to them.
	// This channel is only available for reverse connections.
	C2_HTTPS C2 = 3
	// DNS - A Channel communicating through DNS TXT record requests. As for TCP
	// and HTTP channels, the Channel core will encrypt all data passed through
	// the wire. When used along with a Session Channel core, all networking tools
	// will still be available to use, but there are obviously less guarantees
	// about their throughput capacity first, and will not be OPSEC-safe to use,
	// because of an abnormally large quantity of DNS requests made by a single host.
	// This channel is only available for reverse connections.
	C2_DNS C2 = 4
	// WG - The WireGuard channel starts a complete VPN stack and establishes comms
	// with the server over it. There are multiple control listeners and routines
	// involved with this channel, that is quite deep. However, this channel also
	// includes its own networking pivoting and discovery tools.
	// They are transparently synchronized when you are interacting with an implant
	// over this Channel.
	// This channel is only available for reverse connections.
	C2_WG C2 = 5
	// NamedPipe - This channel is currently only available on Windows
	// implants, but works with Sliver's core routing & pivoting system.
	// It establishes a named pipe between both parties, and exactly like the TCP
	// and HTTP channels, the Channel core will encrypt all data passed on the wire.
	// This channel is available for bind and reverse connections.
	C2_NamedPipe C2 = 6
)

// Enum value maps for C2.
var (
	C2_name = map[int32]string{
		0: "TCP",
		1: "MTLS",
		2: "HTTP",
		3: "HTTPS",
		4: "DNS",
		5: "WG",
		6: "NamedPipe",
	}
	C2_value = map[string]int32{
		"TCP":       0,
		"MTLS":      1,
		"HTTP":      2,
		"HTTPS":     3,
		"DNS":       4,
		"WG":        5,
		"NamedPipe": 6,
	}
)

func (x C2) Enum() *C2 {
	p := new(C2)
	*p = x
	return p
}

func (x C2) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (C2) Descriptor() protoreflect.EnumDescriptor {
	return file_sliverpb_malleable_proto_enumTypes[1].Descriptor()
}

func (C2) Type() protoreflect.EnumType {
	return &file_sliverpb_malleable_proto_enumTypes[1]
}

func (x C2) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use C2.Descriptor instead.
func (C2) EnumDescriptor() ([]byte, []int) {
	return file_sliverpb_malleable_proto_rawDescGZIP(), []int{1}
}

// C2Direction - The direction of the Channel connection, which determines how the
// owner of this profile (the server consuming it, or an implant compiled with it)
// will behave. Note that both values can be spawned as jobs, although a bind (dial)
// will always exit rather quickly, given that the connection will either fail,
// succeed, or wait a given timeout waiting for result. Also, note that, similarly
// to Metasploit's parlance, there is a rule of thumb to ALWAYS remember on which
// direction will do what:
// We always consider the connection from within attacker-controlled territory, and
// the following actions ALWAYS describes what will ultimately a server action to
// establish the channel, eg. the server will either "bind" or "listen for reverse"
// connections initiated from somewhere in non-attacker controlled territory.
type C2Direction int32

const (
	// Bind - In this case, the attacker endpoint (server or pivot implant) dials
	// a remote destination address/path and, if successful, establishes the channel.
	// Note that, as a detail: the Sliver internals are made so that any command
	// spawning a bind handler will not wait for a full Session/Beacon to be set up,
	// and will return either on connection failure, or success. Everything happening
	// after is asynchronous with respect to the handler, as job or not.
	C2Direction_Bind C2Direction = 0
	// Reverse - In this case, the attacker endpoints listens for incoming
	// connection attempts (these come from the target territory). These
	// connections can be either transport/system-level (TCP/UDP/IP) or
	// higher in the OSI model, like HTTP,DNS which are session-based.
	C2Direction_Reverse C2Direction = 1
)

// Enum value maps for C2Direction.
var (
	C2Direction_name = map[int32]string{
		0: "Bind",
		1: "Reverse",
	}
	C2Direction_value = map[string]int32{
		"Bind":    0,
		"Reverse": 1,
	}
)

func (x C2Direction) Enum() *C2Direction {
	p := new(C2Direction)
	*p = x
	return p
}

func (x C2Direction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (C2Direction) Descriptor() protoreflect.EnumDescriptor {
	return file_sliverpb_malleable_proto_enumTypes[2].Descriptor()
}

func (C2Direction) Type() protoreflect.EnumType {
	return &file_sliverpb_malleable_proto_enumTypes[2]
}

func (x C2Direction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use C2Direction.Descriptor instead.
func (C2Direction) EnumDescriptor() ([]byte, []int) {
	return file_sliverpb_malleable_proto_rawDescGZIP(), []int{2}
}

// Malleable - A Malleable profile contains the entire information a C2 Channel
// needs to use as operating parameters, for all protocols, all session types and
// directions. Some fields are base ones, used by all profiles, regardless of their
// stacks, while others might be specific to some.
// All of these options (base and protocol-specific) can be used by both sides of a
// Channel (ex: bind 127.0.0.1 is used by implant to listen, and server to dial).
//
// Also, a Malleable profile integrates its own Security details, which can vary
// greatly across C2 channels, and also depending on the side of the Channel that
// will use the profile.
type Malleable struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// schema is an unexported variable used for schema
	// completion validation when editing the Profile.
	Schema string `protobuf:"bytes,1,opt,name=schema,proto3" json:"$schema"`
	// ID - You should NOT EVER modify the ID of a Malleable profile: even when
	// forking an existing one, copying it, updating it, writing it from scratch:
	// the Sliver server will ALWAYS take care of an ID.
	ID string `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	// ContextSessionID - You should NOT EVER modify the ContextSessionID.
	// This identifies the Session in the context of which this profile was
	// created (a user created it with this session as active).
	ContextSessionID string `protobuf:"bytes,3,opt,name=ContextSessionID,proto3" json:"ContextSessionID,omitempty"`
	// Name - A name for this profile, for easy search in completions
	// and very, very simple one-word description of the profile.
	Name string `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	// Direction - The direction of the Channel connection, which determines how the
	// owner of this profile (the server consuming it, or an implant compiled with
	// it) will behave. Two possible choices:
	// - Bind: The server dials toward an implant listening on a (remote) host/path.
	// - Reverse: The server/implant listens for incoming connections on one of its
	// interfaces/paths.
	Direction C2Direction `protobuf:"varint,10,opt,name=Direction,proto3,enum=sliverpb.C2Direction" json:"Direction,omitempty"`
	// Type- The fundamental type of Channel: this somehow describes the overall
	// and synthetized behavior of this channel, which might be interactive
	// (a Session) or asynchronous (a Beacon).
	// There are important differences between those types, and consequences
	// on tooling availalibity can be significant, as it's the case for network
	// discovery and pivoting tools that are possible through a Session channel,
	// and not on a Beacon one.
	Type C2Type `protobuf:"varint,11,opt,name=Type,proto3,enum=sliverpb.C2Type" json:"Type,omitempty"`
	// C2 - The global name of the networking stack used by this C2. Therefore, many
	// kinds of names can be valid when you add yours; some channels will use the
	// name of their transport protocols (TCP), their applications protocol
	// (DNS/HTTPS) or even specifics about their security details (MTLS, for
	// Mutually Authenticated TLS). Yet other Channels, like WireGuard, are also
	// complete networking stacks of their own.
	C2 C2 `protobuf:"varint,12,opt,name=C2,proto3,enum=sliverpb.C2" json:"C2,omitempty"`
	// Hostname - The name of the target host, WITHOUT any port information.
	Hostname string `protobuf:"bytes,20,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	// Port - An optional port number used by some protocols.
	Port uint32 `protobuf:"varint,21,opt,name=Port,proto3" json:"Port,omitempty"`
	// Path - An optional path used by the application layer of the Channel,
	// for example the path component of a HTTP URL.
	Path string `protobuf:"bytes,22,opt,name=Path,proto3" json:"Path,omitempty"`
	// ControlPort - An optional control port for some Channels (eg: WireGuard, Tor)
	ControlPort uint32 `protobuf:"varint,23,opt,name=ControlPort,proto3" json:"ControlPort,omitempty"`
	// KeyExchangePort - An optional port used for exchanging keys (eg: WireGuard)
	KeyExchangePort uint32 `protobuf:"varint,24,opt,name=KeyExchangePort,proto3" json:"KeyExchangePort,omitempty"`
	// Domains - A series of domains that are either to listen for, or to dial to.
	// TODO: Document this field according to the capacities of Sliver. Will change.
	Domains []string `protobuf:"bytes,25,rep,name=Domains,proto3" json:"Domains,omitempty"`
	// Canaries - If the profile consumer is listening, watch for canary connections.
	Canaries bool `protobuf:"varint,26,opt,name=Canaries,proto3" json:"Canaries,omitempty"`
	// PollTimeout - The maximum amount of times between poll operations for
	// protocols like HTTP or DNS. This is different from both beaconing and
	// reconnect intervals. Also, and as a consequence, this will not have
	// much effect when using a Beacon.
	PollTimeout int64 `protobuf:"varint,40,opt,name=PollTimeout,proto3" json:"PollTimeout,omitempty"`
	// ReconnectInterval - The amount of wait time after a failed (reverse)
	// connection attempt (one side) or bind (other side) attempts.
	// This means:
	// - An unsuccessful attempt to listen on a port is considered failed.
	// - An unsuccessful attempts to dial a destination is considered failed.
	ReconnectInterval int64 `protobuf:"varint,41,opt,name=ReconnectInterval,proto3" json:"ReconnectInterval,omitempty"`
	// MaxErrors - The max number of errors that the consumer is allowed
	// to sustain when connecting/binding its transport stack. This means:
	// - An unsuccessful attempt to listen on a port is considered failed.
	// - An unsuccessful attempts to dial a destination is considered failed.
	// This value is solely used by the transport using this profile, and is
	// not split between other available Transports/Channels on a given host.
	MaxErrors int32 `protobuf:"varint,42,opt,name=MaxErrors,proto3" json:"MaxErrors,omitempty"`
	// Persistent - When this profile is used with a C2 Handler job, the job is saved
	// and will be restarted in the current context (either on the server, or
	// implant if C2 routing is available). Thus, setting this value will only
	// have an effect on C2 channel handlers (jobs), and not on C2 channel
	// transports (implants). In other words, this setting does NOT mean "always
	// start this transport when the implant starts".
	Persistent bool `protobuf:"varint,43,opt,name=Persistent,proto3" json:"Persistent,omitempty"`
	// Active - Used by internals, will soon be deprecated and removed.
	Active bool `protobuf:"varint,44,opt,name=Active,proto3" json:"Active,omitempty"`
	// CommDisabled - Explicitly disallow both parties from establishing an SSH
	// multiplexer on top of this Channel, if it's a Session one. This will thus
	// render most network tools unavailable (like proxies and UDP forwarders),
	// unless the transport stack used by Channel provides its own (eg: WireGuard).
	// To be noted also: this will only have an effect on this Profile, and is NOT
	// a way to explicitly forbid the Comm code to be compiled in the implant.
	CommDisabled bool `protobuf:"varint,45,opt,name=CommDisabled,proto3" json:"CommDisabled,omitempty"`
	// Interval - The base duration used by a Beacon channel to wait before two
	// beacon checkins. This is different from the ReconnectInterval interval field.
	// To be noted, the implant will send an updated next-checkin time to the server
	// over each beaconing run, and those are available in the console tools.
	Interval int64 `protobuf:"varint,60,opt,name=Interval,proto3" json:"Interval,omitempty"`
	// Jitter - The duration seed to use as a variation over the base Interval
	// duration (for time randomness). For example: if a Beacon channel has
	// 10s Interval and 5s Jitter, checkins might look like "12,323s", "13,78s",
	// "7.436s", and so on.
	Jitter int64 `protobuf:"varint,61,opt,name=Jitter,proto3" json:"Jitter,omitempty"`
	// HTTP - This contains the MalleableHTTP contains all HTTP-specific
	// configuration options, exluding security/encryption parameters. There are
	// a few important things to know before editing this Malleable component:
	// - There is a SINGLE HTTP profile type for both server and implant sides
	// of the channel. Thus, some fields might be used by both ends, while other
	// fields will only be used by one of them. All fields in the HTTP section
	// have a documentation specifiying which channel side uses them.
	// - Because different implants might make use of different but overlaping HTTP
	// profiles, the server side of the channel is able to "merge" several HTTP
	// profiles into one at runtime, so as to be able to serve all implants.
	// - If some fields are populated by yourself, and that other required fields
	// remain empty, they will be automatically populated with random samples
	// out of their default lists/values when the Profile is consumed (compiled
	// or used with a handler). Refer to its doc for further info.
	HTTP *MalleableHTTP `protobuf:"bytes,100,opt,name=HTTP,proto3" json:"HTTP,omitempty"`
	// ProxyURL - A system proxy URL that should be used when either the implant
	// is told to so, or if it needs to. In the latter case, the implant has
	// different methods: either fetching environment variables, or use of
	// specialized proxy libraries, such as github.com/aus/proxyplease.
	ProxyURL string `protobuf:"bytes,101,opt,name=ProxyURL,proto3" json:"ProxyURL,omitempty"`
	// Website - When the consumer of this profile is a server, this value is the
	// name of the Website that will be used as a frontend (the website code must
	// exist and be already loaded into the Sliver server: see `websites` command).
	Website string `protobuf:"bytes,102,opt,name=Website,proto3" json:"Website,omitempty"`
	// Credentials - All security elements needed by the profile (certs, keys,
	// logins) for all C2 channel transport stacks. There are thus many possible
	// configurations in this section, and its own documentation aims to describe
	// them exhaustively. Please note, however:
	// Most of the Sliver communication security is assured by a thoughtfully set up
	// Certificate Infrastructure, which handles the different layers of encryption
	// and identity across the Channel stack (transport-layer, core Session/Beacon
	// datastream encryption, one-time secrets, etc).
	// This is performed automatically when handlers are spawned along with a
	// profile, or when transports are compiled into an implant build. Thus,
	// if you don't have a REAL need to customize the encryption further (and
	// 99.999% of the time, you won't), don't touch this field.
	Credentials *Credentials `protobuf:"bytes,200,opt,name=Credentials,proto3" json:"Credentials,omitempty"`
}

func (x *Malleable) Reset() {
	*x = Malleable{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sliverpb_malleable_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Malleable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Malleable) ProtoMessage() {}

func (x *Malleable) ProtoReflect() protoreflect.Message {
	mi := &file_sliverpb_malleable_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Malleable.ProtoReflect.Descriptor instead.
func (*Malleable) Descriptor() ([]byte, []int) {
	return file_sliverpb_malleable_proto_rawDescGZIP(), []int{0}
}

func (x *Malleable) GetSchema() string {
	if x != nil {
		return x.Schema
	}
	return ""
}

func (x *Malleable) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *Malleable) GetContextSessionID() string {
	if x != nil {
		return x.ContextSessionID
	}
	return ""
}

func (x *Malleable) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Malleable) GetDirection() C2Direction {
	if x != nil {
		return x.Direction
	}
	return C2Direction_Bind
}

func (x *Malleable) GetType() C2Type {
	if x != nil {
		return x.Type
	}
	return C2Type_Session
}

func (x *Malleable) GetC2() C2 {
	if x != nil {
		return x.C2
	}
	return C2_TCP
}

func (x *Malleable) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *Malleable) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *Malleable) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *Malleable) GetControlPort() uint32 {
	if x != nil {
		return x.ControlPort
	}
	return 0
}

func (x *Malleable) GetKeyExchangePort() uint32 {
	if x != nil {
		return x.KeyExchangePort
	}
	return 0
}

func (x *Malleable) GetDomains() []string {
	if x != nil {
		return x.Domains
	}
	return nil
}

func (x *Malleable) GetCanaries() bool {
	if x != nil {
		return x.Canaries
	}
	return false
}

func (x *Malleable) GetPollTimeout() int64 {
	if x != nil {
		return x.PollTimeout
	}
	return 0
}

func (x *Malleable) GetReconnectInterval() int64 {
	if x != nil {
		return x.ReconnectInterval
	}
	return 0
}

func (x *Malleable) GetMaxErrors() int32 {
	if x != nil {
		return x.MaxErrors
	}
	return 0
}

func (x *Malleable) GetPersistent() bool {
	if x != nil {
		return x.Persistent
	}
	return false
}

func (x *Malleable) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *Malleable) GetCommDisabled() bool {
	if x != nil {
		return x.CommDisabled
	}
	return false
}

func (x *Malleable) GetInterval() int64 {
	if x != nil {
		return x.Interval
	}
	return 0
}

func (x *Malleable) GetJitter() int64 {
	if x != nil {
		return x.Jitter
	}
	return 0
}

func (x *Malleable) GetHTTP() *MalleableHTTP {
	if x != nil {
		return x.HTTP
	}
	return nil
}

func (x *Malleable) GetProxyURL() string {
	if x != nil {
		return x.ProxyURL
	}
	return ""
}

func (x *Malleable) GetWebsite() string {
	if x != nil {
		return x.Website
	}
	return ""
}

func (x *Malleable) GetCredentials() *Credentials {
	if x != nil {
		return x.Credentials
	}
	return nil
}

// Credentials - All security elements needed by the profile (certs, keys, logins)
// for all C2 channel transport stacks.
// Most of the Sliver communication security is assured by a thoughtfully set up
// Certificate Infrastructure, which handles the different layers of encryption
// and identity across the Channel stack (transport-layer, core Session/Beacon
// datastream encryption, one-time secrets, etc).
// This is performed automatically when handlers are spawned along with a profile,
// or when transports are compiled into an implant build. Thus, if you don't have
// a REAL need to customize the encryption further (and 99.999% of the time, you
// won't), don't touch this field.
// In the future, a much better integration of the Credentials stored in database
// and those fetched on target hosts is likely, and selecting which credentials or
// logins are used within a profile will be easier through console commands and
// their completions.
type Credentials struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// CACertPEM - A PEM-encoded Certificate Authority Public Key, which is used
	// by channels such as MTLS (and HTTPS in some instances), to verify that the
	// identity provided by the remote party is validated by the Sliver server.
	// Note that, more than any other fields, you should not have to populate it on
	// your own, except from if your specific needs have already made you populate
	// ALL other Credentials fields already.
	CACertPEM []byte `protobuf:"bytes,1,opt,name=CACertPEM,proto3" json:"CACertPEM,omitempty"`
	// CertPEM - A PEM-encoded Public Key that can have several usages:
	// - For channels such as MTLS/HTTPS, is used as a Public Key for TLS wrapping
	// if so and mutual authentication is required, this Key will be verified
	// against the CACertPEM, thus, if you intend to use those Channels in a
	// standard way, you won't have to populate this field on your own: the
	// server will take care of it.
	CertPEM []byte `protobuf:"bytes,2,opt,name=CertPEM,proto3" json:"CertPEM,omitempty"`
	// KeyPEM - A PEM-encoded Private Key, which can as well have several usages:
	// - For channels such as MTLS/HTTPS, is used as a Private Key for TLS wrapping.
	KeyPEM []byte `protobuf:"bytes,3,opt,name=KeyPEM,proto3" json:"KeyPEM,omitempty"`
	// ServerFingerprint - The fingerprint of the Certificate Authority is used
	// when the Channel starts the SSH Comm system, which requires authentication.
	// Because this value is fixed across all Channels, it will soon be DEPRECATED.
	ServerFingerprint []byte `protobuf:"bytes,4,opt,name=ServerFingerprint,proto3" json:"ServerFingerprint,omitempty"`
	// ControlServerCert - An optional Public Key used by a control component
	// (like a Key Exchange service for WireGuard, or a Tor control port). Most
	// channels don't make use of this, but it is here so that you don't have
	// to create a new field if you want to add your own (stack-deep) Channel.
	ControlServerCert []byte `protobuf:"bytes,10,opt,name=ControlServerCert,proto3" json:"ControlServerCert,omitempty"`
	// ControlClientKey - An optional Private Key used for decryption of the
	// communications of a control component. This key generally goes hand-in-hand
	// with the ControlServerCert field. Thus, if you intend to set either field
	// on your own (that is, in an editor and out of the Sliver console context),
	// ensure that your fill your related fields correctly.
	ControlClientKey []byte `protobuf:"bytes,11,opt,name=ControlClientKey,proto3" json:"ControlClientKey,omitempty"`
	// TOTPServerSecret - This value is fixed across all Channels,
	// thus not relevant, so it will soon be DEPRECATED.
	TOTPServerSecret []byte `protobuf:"bytes,12,opt,name=TOTPServerSecret,proto3" json:"TOTPServerSecret,omitempty"`
	// LetsEncrypt - Some application-level protocols like HTTPS (not HTTP)
	// may want to connect over "insecure" TLS settings, because the server's
	// end of the Channel can start a LetsEncrypt certificate infrastructure.
	// This might theoretically be applied to any application protocol using TLS,
	// as LetsEncrypt is just an side server component handling some certificate
	// generation/fetching/matching.
	// If true: Starts the LetsEncrypt server on the server end, and connects over
	// insecure TLS on the implant's end.
	// If false: If the Channel still requires TLS set up, the profile uses either
	// user-provided certificates, or certs generated by the Sliver server's PKI.
	LetsEncrypt bool `protobuf:"varint,103,opt,name=LetsEncrypt,proto3" json:"LetsEncrypt,omitempty"`
}

func (x *Credentials) Reset() {
	*x = Credentials{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sliverpb_malleable_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Credentials) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Credentials) ProtoMessage() {}

func (x *Credentials) ProtoReflect() protoreflect.Message {
	mi := &file_sliverpb_malleable_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Credentials.ProtoReflect.Descriptor instead.
func (*Credentials) Descriptor() ([]byte, []int) {
	return file_sliverpb_malleable_proto_rawDescGZIP(), []int{1}
}

func (x *Credentials) GetCACertPEM() []byte {
	if x != nil {
		return x.CACertPEM
	}
	return nil
}

func (x *Credentials) GetCertPEM() []byte {
	if x != nil {
		return x.CertPEM
	}
	return nil
}

func (x *Credentials) GetKeyPEM() []byte {
	if x != nil {
		return x.KeyPEM
	}
	return nil
}

func (x *Credentials) GetServerFingerprint() []byte {
	if x != nil {
		return x.ServerFingerprint
	}
	return nil
}

func (x *Credentials) GetControlServerCert() []byte {
	if x != nil {
		return x.ControlServerCert
	}
	return nil
}

func (x *Credentials) GetControlClientKey() []byte {
	if x != nil {
		return x.ControlClientKey
	}
	return nil
}

func (x *Credentials) GetTOTPServerSecret() []byte {
	if x != nil {
		return x.TOTPServerSecret
	}
	return nil
}

func (x *Credentials) GetLetsEncrypt() bool {
	if x != nil {
		return x.LetsEncrypt
	}
	return false
}

// MalleableHTTP - An HTTP-specific Channel profile. Important notes:
// - There is a SINGLE HTTP profile type for both server and implant sides
// of the channel. Thus, some fields might be used by both ends, while other
// fields will only be used by one of them. All fields in the HTTP section
// have a documentation specifiying which channel side uses them.
// - Because different implants might make use of different but overlaping HTTP
// profiles, the server side of the channel is able to "merge" several HTTP
// profiles into one at runtime, so as to be able to serve all implants.
// - If some fields are populated by yourself, and that other required fields
// remain empty, they will be automatically populated with random samples out
// of their default lists/values when the Profile is consumed (compiled or used
// with a handler)
type MalleableHTTP struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// ID - You should NOT EVER modify the ID of a Malleable profile: even when
	// forking an existing one, copying it, updating it, writing it from scratch:
	// the Sliver server will ALWAYS take care of an ID.
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// UserAgent - The User Agent value is only used when this Profile is consumed
	// by an implant Transport, because the implant is (always) acting as the client.
	// If this string is empty, the Server will ALWAYS take care of generating a new
	// random one. If this field is already populated, that likely means the server
	// already generated one for the profile you are currently editing.
	// You can change it however you like: it will override the previous value.
	// Important: Implant-side field only
	UserAgent string `protobuf:"bytes,2,opt,name=UserAgent,proto3" json:"UserAgent,omitempty"`
	// URLParameters - The URL parameters are some of those fields that will stay
	// the same across all HTTP requests: thus, they are not randomized on a
	// per-request basis. Currently the HTTP Channel implementation doesn't make
	// use of this field.
	URLParameters []string `protobuf:"bytes,3,rep,name=URLParameters,proto3" json:"URLParameters,omitempty"`
	// Headers - The headers of every HTTP request. If this array is empty, the
	// Server will automatically use the following headers (there are risks that
	// this list is not up-to-date though):
	//
	// ["Cache-Control", "no-store, no-cache, must-revalidate"]
	//
	// Important: Server-side field only
	Headers []string `protobuf:"bytes,4,rep,name=Headers,proto3" json:"Headers,omitempty"`
	// MaxFiles - The maximum number of complete file names (ex: mysessionfile.txt),
	// that are generated for each SAMPLE, sample being passed to the HTTP C2
	// internals for generating a random request URL. Defaults to 8.
	//
	// Important: Implant-side field only
	MaxFiles int32 `protobuf:"varint,5,opt,name=MaxFiles,proto3" json:"MaxFiles,omitempty"`
	// MinFiles - The minimum number of complete file names (ex: mysessionfile.txt),
	// that are generated for each SAMPLE, sample being passed to the HTTP C2
	// internals for generating a random request URL. Defaults to 2.
	//
	// Important: Implant-side field only
	MinFiles int32 `protobuf:"varint,6,opt,name=MinFiles,proto3" json:"MinFiles,omitempty"`
	// MaxPaths - The maximum number of paths (eg: "my/path/to" in the following URL:
	// "https://example.domain.com/my/path/to/mysessionfile.txt") that are generated
	// for each SAMPLE, sample being passed to the HTTP C2 internals for generating
	// a random request URL. Defaults to 8.
	//
	// Important: Implant-side field only
	MaxPaths int32 `protobuf:"varint,7,opt,name=MaxPaths,proto3" json:"MaxPaths,omitempty"`
	// MinPaths - The minimum number of paths (eg: "my/path/to" in the following URL:
	// "https://example.domain.com/my/path/to/mysessionfile.txt") that are generated
	// for each SAMPLE, sample being passed to the HTTP C2 internals for generating
	// a random request URL. Defaults to 2.
	//
	// Important: Implant-side field only
	MinPaths int32 `protobuf:"varint,8,opt,name=MinPaths,proto3" json:"MinPaths,omitempty"`
	// StagerFileExt - The Stager file extension is consumed by an HTTP server
	// consuming this Profile. All incoming connections requesting a URL ending
	// with this extension will be served an implant stage.
	//
	// Default: ".woff"
	//
	// Important: Server-side field only
	StagerFileExt string `protobuf:"bytes,9,opt,name=StagerFileExt,proto3" json:"StagerFileExt,omitempty"`
	// KeyExchangeFileExt - Key Exchange file extension. (default .txt)
	// Important: Server/Implant field
	KeyExchangeFileExt string `protobuf:"bytes,10,opt,name=KeyExchangeFileExt,proto3" json:"KeyExchangeFileExt,omitempty"`
	// KeyExchangeFiles - Filenames for key exchange requests.
	//
	// Default list:
	// "robots", "sample", "readme", "example"
	//
	// Important: Server/Implant field
	KeyExchangeFiles []string `protobuf:"bytes,11,rep,name=KeyExchangeFiles,proto3" json:"KeyExchangeFiles,omitempty"`
	// KeyExchangePaths - URL paths for key exchange requests.
	//
	// Default list:
	// "static", "www", "assets", "text", "docs",
	// "sample", "data", "readme", "examples"
	//
	// Important: Server/Implant field
	KeyExchangePaths []string `protobuf:"bytes,13,rep,name=KeyExchangePaths,proto3" json:"KeyExchangePaths,omitempty"`
	// PollFileExt - Session Polling file extension. For a normal Session/Beacon
	// Channel, polling files are the most used ones, because most of the
	// underlying stream content passes through them (default: .js)
	//
	// Important: Server/Implant field
	PollFileExt string `protobuf:"bytes,15,opt,name=PollFileExt,proto3" json:"PollFileExt,omitempty"`
	// PollFiles - Filenames for session polling requests.
	//
	// Default list:
	// "bootstrap", "bootstrap.min", "jquery.min", "jquery", "route",
	// "app", "app.min", "array", "backbone", "script", "email",
	//
	// Important: Server/Implant field
	PollFiles []string `protobuf:"bytes,16,rep,name=PollFiles,proto3" json:"PollFiles,omitempty"`
	// PollPaths - URL paths for session polling requests.
	//
	// Default list:
	// "js", "umd", "assets", "bundle", "bundles", "scripts", "script",
	// "javascripts", "javascript", "jscript",
	//
	// Important: Server/Implant field
	PollPaths []string `protobuf:"bytes,17,rep,name=PollPaths,proto3" json:"PollPaths,omitempty"`
	// StartSessionFileExt - File extension for requests to start a new Session.
	// This is also used by Beacon channels because as the Malleable.Type
	// documentation above explains, the Session type is used by Beacon channels.
	// (default .phtml)
	//
	// Important: Server/Implant field
	StartSessionFileExt string `protobuf:"bytes,18,opt,name=StartSessionFileExt,proto3" json:"StartSessionFileExt,omitempty"`
	// SessionFileExt - Session files requests are used when the implant side
	// of the channel (the client) wants to write data back to the server. Thus,
	// session files are also used a lot, like Poll requests. (default: .php)
	SessionFileExt string `protobuf:"bytes,20,opt,name=SessionFileExt,proto3" json:"SessionFileExt,omitempty"`
	// SessionFiles - Filenames for session (write data to server) requests.
	//
	// Default list:
	// "login", "signin", "api", "samples", "rpc", "index",
	// "admin", "register", "sign-up",
	//
	// Important: Server/Implant field
	SessionFiles []string `protobuf:"bytes,21,rep,name=SessionFiles,proto3" json:"SessionFiles,omitempty"`
	// SessionPaths - URL paths for session (write data to server) requests.
	//
	// Default list:
	// "php", "api", "upload", "actions", "rest", "v1", "auth", "authenticate",
	// "oauth", "oauth2", "oauth2callback", "database", "db", "namespaces",
	//
	// Important: Server/Implant field
	SessionPaths []string `protobuf:"bytes,22,rep,name=SessionPaths,proto3" json:"SessionPaths,omitempty"`
	// CloseFileExt - The file extension used for requests to close the HTTP Channel.
	// (default: .png)
	//
	// Important: Server/Implant field
	CloseFileExt string `protobuf:"bytes,23,opt,name=CloseFileExt,proto3" json:"CloseFileExt,omitempty"`
	// CloseFiles - Filenames for Session close requests.
	//
	// Default list: "favicon", "sample", "example",
	//
	// Important: Server/Implant field
	CloseFiles []string `protobuf:"bytes,24,rep,name=CloseFiles,proto3" json:"CloseFiles,omitempty"`
	// ClosePaths - URL paths for Session close requests.
	//
	// Default list:
	// "static", "www", "assets", "images", "icons", "image", "icon", "png",
	//
	// Important: Server/Implant field
	ClosePaths []string `protobuf:"bytes,25,rep,name=ClosePaths,proto3" json:"ClosePaths,omitempty"`
}

func (x *MalleableHTTP) Reset() {
	*x = MalleableHTTP{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sliverpb_malleable_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MalleableHTTP) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MalleableHTTP) ProtoMessage() {}

func (x *MalleableHTTP) ProtoReflect() protoreflect.Message {
	mi := &file_sliverpb_malleable_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MalleableHTTP.ProtoReflect.Descriptor instead.
func (*MalleableHTTP) Descriptor() ([]byte, []int) {
	return file_sliverpb_malleable_proto_rawDescGZIP(), []int{2}
}

func (x *MalleableHTTP) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *MalleableHTTP) GetUserAgent() string {
	if x != nil {
		return x.UserAgent
	}
	return ""
}

func (x *MalleableHTTP) GetURLParameters() []string {
	if x != nil {
		return x.URLParameters
	}
	return nil
}

func (x *MalleableHTTP) GetHeaders() []string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *MalleableHTTP) GetMaxFiles() int32 {
	if x != nil {
		return x.MaxFiles
	}
	return 0
}

func (x *MalleableHTTP) GetMinFiles() int32 {
	if x != nil {
		return x.MinFiles
	}
	return 0
}

func (x *MalleableHTTP) GetMaxPaths() int32 {
	if x != nil {
		return x.MaxPaths
	}
	return 0
}

func (x *MalleableHTTP) GetMinPaths() int32 {
	if x != nil {
		return x.MinPaths
	}
	return 0
}

func (x *MalleableHTTP) GetStagerFileExt() string {
	if x != nil {
		return x.StagerFileExt
	}
	return ""
}

func (x *MalleableHTTP) GetKeyExchangeFileExt() string {
	if x != nil {
		return x.KeyExchangeFileExt
	}
	return ""
}

func (x *MalleableHTTP) GetKeyExchangeFiles() []string {
	if x != nil {
		return x.KeyExchangeFiles
	}
	return nil
}

func (x *MalleableHTTP) GetKeyExchangePaths() []string {
	if x != nil {
		return x.KeyExchangePaths
	}
	return nil
}

func (x *MalleableHTTP) GetPollFileExt() string {
	if x != nil {
		return x.PollFileExt
	}
	return ""
}

func (x *MalleableHTTP) GetPollFiles() []string {
	if x != nil {
		return x.PollFiles
	}
	return nil
}

func (x *MalleableHTTP) GetPollPaths() []string {
	if x != nil {
		return x.PollPaths
	}
	return nil
}

func (x *MalleableHTTP) GetStartSessionFileExt() string {
	if x != nil {
		return x.StartSessionFileExt
	}
	return ""
}

func (x *MalleableHTTP) GetSessionFileExt() string {
	if x != nil {
		return x.SessionFileExt
	}
	return ""
}

func (x *MalleableHTTP) GetSessionFiles() []string {
	if x != nil {
		return x.SessionFiles
	}
	return nil
}

func (x *MalleableHTTP) GetSessionPaths() []string {
	if x != nil {
		return x.SessionPaths
	}
	return nil
}

func (x *MalleableHTTP) GetCloseFileExt() string {
	if x != nil {
		return x.CloseFileExt
	}
	return ""
}

func (x *MalleableHTTP) GetCloseFiles() []string {
	if x != nil {
		return x.CloseFiles
	}
	return nil
}

func (x *MalleableHTTP) GetClosePaths() []string {
	if x != nil {
		return x.ClosePaths
	}
	return nil
}

var File_sliverpb_malleable_proto protoreflect.FileDescriptor

var file_sliverpb_malleable_proto_rawDesc = []byte{
	0x0a, 0x18, 0x73, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x70, 0x62, 0x2f, 0x6d, 0x61, 0x6c, 0x6c, 0x65,
	0x61, 0x62, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x73, 0x6c, 0x69, 0x76,
	0x65, 0x72, 0x70, 0x62, 0x1a, 0x13, 0x74, 0x61, 0x67, 0x67, 0x65, 0x72, 0x2f, 0x74, 0x61, 0x67,
	0x67, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xe2, 0x06, 0x0a, 0x09, 0x4d, 0x61,
	0x6c, 0x6c, 0x65, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x2b, 0x0a, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d,
	0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x13, 0x9a, 0x84, 0x9e, 0x03, 0x0e, 0x6a, 0x73,
	0x6f, 0x6e, 0x3a, 0x22, 0x24, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x22, 0x52, 0x06, 0x73, 0x63,
	0x68, 0x65, 0x6d, 0x61, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x02, 0x49, 0x44, 0x12, 0x2a, 0x0a, 0x10, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x53,
	0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10,
	0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44,
	0x12, 0x12, 0x0a, 0x04, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x4e, 0x61, 0x6d, 0x65, 0x12, 0x33, 0x0a, 0x09, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x15, 0x2e, 0x73, 0x6c, 0x69, 0x76, 0x65, 0x72,
	0x70, 0x62, 0x2e, 0x43, 0x32, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x09,
	0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x04, 0x54, 0x79, 0x70,
	0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x73, 0x6c, 0x69, 0x76, 0x65, 0x72,
	0x70, 0x62, 0x2e, 0x43, 0x32, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12,
	0x1c, 0x0a, 0x02, 0x43, 0x32, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0c, 0x2e, 0x73, 0x6c,
	0x69, 0x76, 0x65, 0x72, 0x70, 0x62, 0x2e, 0x43, 0x32, 0x52, 0x02, 0x43, 0x32, 0x12, 0x1a, 0x0a,
	0x08, 0x48, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x14, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x08, 0x48, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x50, 0x6f, 0x72,
	0x74, 0x18, 0x15, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x12, 0x0a,
	0x04, 0x50, 0x61, 0x74, 0x68, 0x18, 0x16, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x50, 0x61, 0x74,
	0x68, 0x12, 0x20, 0x0a, 0x0b, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x50, 0x6f, 0x72, 0x74,
	0x18, 0x17, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x50,
	0x6f, 0x72, 0x74, 0x12, 0x28, 0x0a, 0x0f, 0x4b, 0x65, 0x79, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e,
	0x67, 0x65, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x18, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0f, 0x4b, 0x65,
	0x79, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x18, 0x0a,
	0x07, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x19, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07,
	0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x43, 0x61, 0x6e, 0x61, 0x72,
	0x69, 0x65, 0x73, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x43, 0x61, 0x6e, 0x61, 0x72,
	0x69, 0x65, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x50, 0x6f, 0x6c, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x6f,
	0x75, 0x74, 0x18, 0x28, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x50, 0x6f, 0x6c, 0x6c, 0x54, 0x69,
	0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x2c, 0x0a, 0x11, 0x52, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65,
	0x63, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x29, 0x20, 0x01, 0x28, 0x03,
	0x52, 0x11, 0x52, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72,
	0x76, 0x61, 0x6c, 0x12, 0x1c, 0x0a, 0x09, 0x4d, 0x61, 0x78, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73,
	0x18, 0x2a, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x4d, 0x61, 0x78, 0x45, 0x72, 0x72, 0x6f, 0x72,
	0x73, 0x12, 0x1e, 0x0a, 0x0a, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x18,
	0x2b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e,
	0x74, 0x12, 0x16, 0x0a, 0x06, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x2c, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x06, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x43, 0x6f, 0x6d,
	0x6d, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x2d, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x0c, 0x43, 0x6f, 0x6d, 0x6d, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1a, 0x0a,
	0x08, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x3c, 0x20, 0x01, 0x28, 0x03, 0x52,
	0x08, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x16, 0x0a, 0x06, 0x4a, 0x69, 0x74,
	0x74, 0x65, 0x72, 0x18, 0x3d, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x4a, 0x69, 0x74, 0x74, 0x65,
	0x72, 0x12, 0x2b, 0x0a, 0x04, 0x48, 0x54, 0x54, 0x50, 0x18, 0x64, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x17, 0x2e, 0x73, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x70, 0x62, 0x2e, 0x4d, 0x61, 0x6c, 0x6c, 0x65,
	0x61, 0x62, 0x6c, 0x65, 0x48, 0x54, 0x54, 0x50, 0x52, 0x04, 0x48, 0x54, 0x54, 0x50, 0x12, 0x1a,
	0x0a, 0x08, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x55, 0x52, 0x4c, 0x18, 0x65, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x55, 0x52, 0x4c, 0x12, 0x18, 0x0a, 0x07, 0x57, 0x65,
	0x62, 0x73, 0x69, 0x74, 0x65, 0x18, 0x66, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x57, 0x65, 0x62,
	0x73, 0x69, 0x74, 0x65, 0x12, 0x38, 0x0a, 0x0b, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69,
	0x61, 0x6c, 0x73, 0x18, 0xc8, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x73, 0x6c, 0x69,
	0x76, 0x65, 0x72, 0x70, 0x62, 0x2e, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c,
	0x73, 0x52, 0x0b, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x22, 0xb3,
	0x02, 0x0a, 0x0b, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x12, 0x1c,
	0x0a, 0x09, 0x43, 0x41, 0x43, 0x65, 0x72, 0x74, 0x50, 0x45, 0x4d, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0c, 0x52, 0x09, 0x43, 0x41, 0x43, 0x65, 0x72, 0x74, 0x50, 0x45, 0x4d, 0x12, 0x18, 0x0a, 0x07,
	0x43, 0x65, 0x72, 0x74, 0x50, 0x45, 0x4d, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x43,
	0x65, 0x72, 0x74, 0x50, 0x45, 0x4d, 0x12, 0x16, 0x0a, 0x06, 0x4b, 0x65, 0x79, 0x50, 0x45, 0x4d,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x4b, 0x65, 0x79, 0x50, 0x45, 0x4d, 0x12, 0x2c,
	0x0a, 0x11, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x46, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x70, 0x72,
	0x69, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x11, 0x53, 0x65, 0x72, 0x76, 0x65,
	0x72, 0x46, 0x69, 0x6e, 0x67, 0x65, 0x72, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x12, 0x2c, 0x0a, 0x11,
	0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x43, 0x65, 0x72,
	0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x11, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
	0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x43, 0x65, 0x72, 0x74, 0x12, 0x2a, 0x0a, 0x10, 0x43, 0x6f,
	0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4b, 0x65, 0x79, 0x18, 0x0b,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x10, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x43, 0x6c, 0x69,
	0x65, 0x6e, 0x74, 0x4b, 0x65, 0x79, 0x12, 0x2a, 0x0a, 0x10, 0x54, 0x4f, 0x54, 0x50, 0x53, 0x65,
	0x72, 0x76, 0x65, 0x72, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x10, 0x54, 0x4f, 0x54, 0x50, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x53, 0x65, 0x63, 0x72,
	0x65, 0x74, 0x12, 0x20, 0x0a, 0x0b, 0x4c, 0x65, 0x74, 0x73, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70,
	0x74, 0x18, 0x67, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x4c, 0x65, 0x74, 0x73, 0x45, 0x6e, 0x63,
	0x72, 0x79, 0x70, 0x74, 0x22, 0xff, 0x05, 0x0a, 0x0d, 0x4d, 0x61, 0x6c, 0x6c, 0x65, 0x61, 0x62,
	0x6c, 0x65, 0x48, 0x54, 0x54, 0x50, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x12, 0x1c, 0x0a, 0x09, 0x55, 0x73, 0x65, 0x72, 0x41, 0x67,
	0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x55, 0x73, 0x65, 0x72, 0x41,
	0x67, 0x65, 0x6e, 0x74, 0x12, 0x24, 0x0a, 0x0d, 0x55, 0x52, 0x4c, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0d, 0x55, 0x52, 0x4c,
	0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x48, 0x65,
	0x61, 0x64, 0x65, 0x72, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x48, 0x65, 0x61,
	0x64, 0x65, 0x72, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x4d, 0x61, 0x78, 0x46, 0x69, 0x6c, 0x65, 0x73,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x4d, 0x61, 0x78, 0x46, 0x69, 0x6c, 0x65, 0x73,
	0x12, 0x1a, 0x0a, 0x08, 0x4d, 0x69, 0x6e, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x08, 0x4d, 0x69, 0x6e, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08,
	0x4d, 0x61, 0x78, 0x50, 0x61, 0x74, 0x68, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08,
	0x4d, 0x61, 0x78, 0x50, 0x61, 0x74, 0x68, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x4d, 0x69, 0x6e, 0x50,
	0x61, 0x74, 0x68, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x4d, 0x69, 0x6e, 0x50,
	0x61, 0x74, 0x68, 0x73, 0x12, 0x24, 0x0a, 0x0d, 0x53, 0x74, 0x61, 0x67, 0x65, 0x72, 0x46, 0x69,
	0x6c, 0x65, 0x45, 0x78, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x53, 0x74, 0x61,
	0x67, 0x65, 0x72, 0x46, 0x69, 0x6c, 0x65, 0x45, 0x78, 0x74, 0x12, 0x2e, 0x0a, 0x12, 0x4b, 0x65,
	0x79, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x45, 0x78, 0x74,
	0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x4b, 0x65, 0x79, 0x45, 0x78, 0x63, 0x68, 0x61,
	0x6e, 0x67, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x45, 0x78, 0x74, 0x12, 0x2a, 0x0a, 0x10, 0x4b, 0x65,
	0x79, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x0b,
	0x20, 0x03, 0x28, 0x09, 0x52, 0x10, 0x4b, 0x65, 0x79, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67,
	0x65, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x2a, 0x0a, 0x10, 0x4b, 0x65, 0x79, 0x45, 0x78, 0x63,
	0x68, 0x61, 0x6e, 0x67, 0x65, 0x50, 0x61, 0x74, 0x68, 0x73, 0x18, 0x0d, 0x20, 0x03, 0x28, 0x09,
	0x52, 0x10, 0x4b, 0x65, 0x79, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x50, 0x61, 0x74,
	0x68, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x50, 0x6f, 0x6c, 0x6c, 0x46, 0x69, 0x6c, 0x65, 0x45, 0x78,
	0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x50, 0x6f, 0x6c, 0x6c, 0x46, 0x69, 0x6c,
	0x65, 0x45, 0x78, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x50, 0x6f, 0x6c, 0x6c, 0x46, 0x69, 0x6c, 0x65,
	0x73, 0x18, 0x10, 0x20, 0x03, 0x28, 0x09, 0x52, 0x09, 0x50, 0x6f, 0x6c, 0x6c, 0x46, 0x69, 0x6c,
	0x65, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x50, 0x6f, 0x6c, 0x6c, 0x50, 0x61, 0x74, 0x68, 0x73, 0x18,
	0x11, 0x20, 0x03, 0x28, 0x09, 0x52, 0x09, 0x50, 0x6f, 0x6c, 0x6c, 0x50, 0x61, 0x74, 0x68, 0x73,
	0x12, 0x30, 0x0a, 0x13, 0x53, 0x74, 0x61, 0x72, 0x74, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
	0x46, 0x69, 0x6c, 0x65, 0x45, 0x78, 0x74, 0x18, 0x12, 0x20, 0x01, 0x28, 0x09, 0x52, 0x13, 0x53,
	0x74, 0x61, 0x72, 0x74, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x46, 0x69, 0x6c, 0x65, 0x45,
	0x78, 0x74, 0x12, 0x26, 0x0a, 0x0e, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x46, 0x69, 0x6c,
	0x65, 0x45, 0x78, 0x74, 0x18, 0x14, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x53, 0x65, 0x73, 0x73,
	0x69, 0x6f, 0x6e, 0x46, 0x69, 0x6c, 0x65, 0x45, 0x78, 0x74, 0x12, 0x22, 0x0a, 0x0c, 0x53, 0x65,
	0x73, 0x73, 0x69, 0x6f, 0x6e, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x15, 0x20, 0x03, 0x28, 0x09,
	0x52, 0x0c, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x22,
	0x0a, 0x0c, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x74, 0x68, 0x73, 0x18, 0x16,
	0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x74,
	0x68, 0x73, 0x12, 0x22, 0x0a, 0x0c, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x45,
	0x78, 0x74, 0x18, 0x17, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x46,
	0x69, 0x6c, 0x65, 0x45, 0x78, 0x74, 0x12, 0x1e, 0x0a, 0x0a, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x46,
	0x69, 0x6c, 0x65, 0x73, 0x18, 0x18, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x43, 0x6c, 0x6f, 0x73,
	0x65, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x1e, 0x0a, 0x0a, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x50,
	0x61, 0x74, 0x68, 0x73, 0x18, 0x19, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x43, 0x6c, 0x6f, 0x73,
	0x65, 0x50, 0x61, 0x74, 0x68, 0x73, 0x2a, 0x21, 0x0a, 0x06, 0x43, 0x32, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x0b, 0x0a, 0x07, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x10, 0x00, 0x12, 0x0a, 0x0a,
	0x06, 0x42, 0x65, 0x61, 0x63, 0x6f, 0x6e, 0x10, 0x01, 0x2a, 0x4c, 0x0a, 0x02, 0x43, 0x32, 0x12,
	0x07, 0x0a, 0x03, 0x54, 0x43, 0x50, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x4d, 0x54, 0x4c, 0x53,
	0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x48, 0x54, 0x54, 0x50, 0x10, 0x02, 0x12, 0x09, 0x0a, 0x05,
	0x48, 0x54, 0x54, 0x50, 0x53, 0x10, 0x03, 0x12, 0x07, 0x0a, 0x03, 0x44, 0x4e, 0x53, 0x10, 0x04,
	0x12, 0x06, 0x0a, 0x02, 0x57, 0x47, 0x10, 0x05, 0x12, 0x0d, 0x0a, 0x09, 0x4e, 0x61, 0x6d, 0x65,
	0x64, 0x50, 0x69, 0x70, 0x65, 0x10, 0x06, 0x2a, 0x24, 0x0a, 0x0b, 0x43, 0x32, 0x44, 0x69, 0x72,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x08, 0x0a, 0x04, 0x42, 0x69, 0x6e, 0x64, 0x10, 0x00,
	0x12, 0x0b, 0x0a, 0x07, 0x52, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x10, 0x01, 0x42, 0x8d, 0x01,
	0x0a, 0x0c, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x70, 0x62, 0x42, 0x0e,
	0x4d, 0x61, 0x6c, 0x6c, 0x65, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01,
	0x5a, 0x2d, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x69, 0x73,
	0x68, 0x6f, 0x70, 0x66, 0x6f, 0x78, 0x2f, 0x73, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x2f, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x73, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x70, 0x62, 0xa2,
	0x02, 0x03, 0x53, 0x58, 0x58, 0xaa, 0x02, 0x08, 0x53, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x70, 0x62,
	0xca, 0x02, 0x08, 0x53, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x70, 0x62, 0xe2, 0x02, 0x14, 0x53, 0x6c,
	0x69, 0x76, 0x65, 0x72, 0x70, 0x62, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61,
	0x74, 0x61, 0xea, 0x02, 0x08, 0x53, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x70, 0x62, 0x62, 0x06, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_sliverpb_malleable_proto_rawDescOnce sync.Once
	file_sliverpb_malleable_proto_rawDescData = file_sliverpb_malleable_proto_rawDesc
)

func file_sliverpb_malleable_proto_rawDescGZIP() []byte {
	file_sliverpb_malleable_proto_rawDescOnce.Do(func() {
		file_sliverpb_malleable_proto_rawDescData = protoimpl.X.CompressGZIP(file_sliverpb_malleable_proto_rawDescData)
	})
	return file_sliverpb_malleable_proto_rawDescData
}

var file_sliverpb_malleable_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_sliverpb_malleable_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_sliverpb_malleable_proto_goTypes = []interface{}{
	(C2Type)(0),           // 0: sliverpb.C2Type
	(C2)(0),               // 1: sliverpb.C2
	(C2Direction)(0),      // 2: sliverpb.C2Direction
	(*Malleable)(nil),     // 3: sliverpb.Malleable
	(*Credentials)(nil),   // 4: sliverpb.Credentials
	(*MalleableHTTP)(nil), // 5: sliverpb.MalleableHTTP
}
var file_sliverpb_malleable_proto_depIdxs = []int32{
	2, // 0: sliverpb.Malleable.Direction:type_name -> sliverpb.C2Direction
	0, // 1: sliverpb.Malleable.Type:type_name -> sliverpb.C2Type
	1, // 2: sliverpb.Malleable.C2:type_name -> sliverpb.C2
	5, // 3: sliverpb.Malleable.HTTP:type_name -> sliverpb.MalleableHTTP
	4, // 4: sliverpb.Malleable.Credentials:type_name -> sliverpb.Credentials
	5, // [5:5] is the sub-list for method output_type
	5, // [5:5] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_sliverpb_malleable_proto_init() }
func file_sliverpb_malleable_proto_init() {
	if File_sliverpb_malleable_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_sliverpb_malleable_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Malleable); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sliverpb_malleable_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Credentials); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sliverpb_malleable_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MalleableHTTP); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_sliverpb_malleable_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_sliverpb_malleable_proto_goTypes,
		DependencyIndexes: file_sliverpb_malleable_proto_depIdxs,
		EnumInfos:         file_sliverpb_malleable_proto_enumTypes,
		MessageInfos:      file_sliverpb_malleable_proto_msgTypes,
	}.Build()
	File_sliverpb_malleable_proto = out.File
	file_sliverpb_malleable_proto_rawDesc = nil
	file_sliverpb_malleable_proto_goTypes = nil
	file_sliverpb_malleable_proto_depIdxs = nil
}
