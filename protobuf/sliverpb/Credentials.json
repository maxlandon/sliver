{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "$ref": "#/definitions/Credentials",
    "definitions": {
        "Credentials": {
            "properties": {
                "CACertPEM": {
                    "type": "string",
                    "description": "CACertPEM - A PEM-encoded Certificate Authority Public Key, which is used \n by channels such as MTLS (and HTTPS in some instances), to verify that the \n identity provided by the remote party is validated by the Sliver server. \n Note that, more than any other fields, you should not have to populate it on \n your own, except from if your specific needs have already made you populate \n ALL other Credentials fields already.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "CertPEM": {
                    "type": "string",
                    "description": "CertPEM - A PEM-encoded Public Key that can have several usages:\n - For channels such as MTLS/HTTPS, is used as a Public Key for TLS wrapping \n if so and mutual authentication is required, this Key will be verified \n against the CACertPEM, thus, if you intend to use those Channels in a \n standard way, you won't have to populate this field on your own: the \n server will take care of it.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "KeyPEM": {
                    "type": "string",
                    "description": "KeyPEM - A PEM-encoded Private Key, which can as well have several usages:\n - For channels such as MTLS/HTTPS, is used as a Private Key for TLS wrapping.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "ServerFingerprint": {
                    "type": "string",
                    "description": "ServerFingerprint - The fingerprint of the Certificate Authority is used \n when the Channel starts the SSH Comm system, which requires authentication. \n Because this value is fixed across all Channels, it will soon be DEPRECATED.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "ControlServerCert": {
                    "type": "string",
                    "description": "ControlServerCert - An optional Public Key used by a control component \n (like a Key Exchange service for WireGuard, or a Tor control port). Most\n channels don't make use of this, but it is here so that you don't have\n to create a new field if you want to add your own (stack-deep) Channel.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "ControlClientKey": {
                    "type": "string",
                    "description": "ControlClientKey - An optional Private Key used for decryption of the\n communications of a control component. This key generally goes hand-in-hand \n with the ControlServerCert field. Thus, if you intend to set either field\n on your own (that is, in an editor and out of the Sliver console context),\n ensure that your fill your related fields correctly.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "TOTPServerSecret": {
                    "type": "string",
                    "description": "TOTPServerSecret - This value is fixed across all Channels, \n thus not relevant, so it will soon be DEPRECATED.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "LetsEncrypt": {
                    "type": "boolean",
                    "description": "LetsEncrypt - Some application-level protocols like HTTPS (not HTTP) \n may want to connect over \"insecure\" TLS settings, because the server's \n end of the Channel can start a LetsEncrypt certificate infrastructure. \n This might theoretically be applied to any application protocol using TLS, \n as LetsEncrypt is just an side server component handling some certificate \n generation/fetching/matching.\n If true: Starts the LetsEncrypt server on the server end, and connects over\n insecure TLS on the implant's end.\n If false: If the Channel still requires TLS set up, the profile uses either\n user-provided certificates, or certs generated by the Sliver server's PKI."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Credentials - All security elements needed by the profile (certs, keys, logins)\n for all C2 channel transport stacks. \n Most of the Sliver communication security is assured by a thoughtfully set up\n Certificate Infrastructure, which handles the different layers of encryption\n and identity across the Channel stack (transport-layer, core Session/Beacon \n datastream encryption, one-time secrets, etc). \n This is performed automatically when handlers are spawned along with a profile, \n or when transports are compiled into an implant build. Thus, if you don't have \n a REAL need to customize the encryption further (and 99.999% of the time, you \n won't), don't touch this field.\n In the future, a much better integration of the Credentials stored in database \n and those fetched on target hosts is likely, and selecting which credentials or \n logins are used within a profile will be easier through console commands and \n their completions."
        }
    }
}