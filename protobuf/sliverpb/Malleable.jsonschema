{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "$ref": "#/definitions/Malleable",
    "definitions": {
        "Malleable": {
            "properties": {
                "schema": {
                    "type": "string",
                    "description": "schema is an unexported variable used for schema \n completion validation when editing the Profile.\n string schema = 1 [(tagger.tags) = \"json:\\\"$schema\\\"\"];"
                },
                "ID": {
                    "type": "string",
                    "description": "ID - You should NOT EVER modify the ID of a Malleable profile: even when \n forking an existing one, copying it, updating it, writing it from scratch: \n the Sliver server will ALWAYS take care of an ID."
                },
                "ContextSessionID": {
                    "type": "string",
                    "description": "ContextSessionID - You should NOT EVER modify the ContextSessionID. \n This identifies the Session in the context of which this profile was \n created (a user created it with this session as active)."
                },
                "Name": {
                    "type": "string",
                    "description": "Name - A name for this profile, for easy search in completions \n and very, very simple one-word description of the profile."
                },
                "Direction": {
                    "enum": [
                        "Bind",
                        0,
                        "Reverse",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "description": "Direction - The direction of the Channel connection, which determines how the \n owner of this profile (the server consuming it, or an implant compiled with \n it) will behave. Two possible choices:\n Bind - The server dials toward an implant listening on a (remote) host/path.\n Reverse - The server/implant listens for incoming connections on one of its \n interfaces/paths."
                },
                "Type": {
                    "enum": [
                        "Session",
                        0,
                        "Beacon",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "description": "Type- The fundamental type of Channel: this somehow describes the overall\n and synthetized behavior of this channel, which might be interactive\n (a Session) or asynchronous (a Beacon).\n There are important differences between those types, and consequences \n on tooling availalibity can be significant, as it's the case for network \n discovery and pivoting tools that are possible through a Session channel, \n and not on a Beacon one."
                },
                "C2": {
                    "enum": [
                        "TCP",
                        0,
                        "MTLS",
                        1,
                        "HTTP",
                        2,
                        "HTTPS",
                        3,
                        "DNS",
                        4,
                        "WG",
                        5,
                        "NamedPipe",
                        6
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "description": "C2 - The global name of the networking stack used by this C2. Therefore, many\n kinds of names can be valid when you add yours; some channels will use the\n name of their transport protocols (TCP), their applications protocol \n (DNS/HTTPS) or even specifics about their security details (MTLS, for \n Mutually Authenticated TLS). Yet other Channels, like WireGuard, are also \n complete networking stacks of their own."
                },
                "Hostname": {
                    "type": "string",
                    "description": "Hostname - The name of the target host, WITHOUT any port information."
                },
                "Port": {
                    "type": "integer",
                    "description": "Port - An optional port number used by some protocols."
                },
                "Path": {
                    "type": "string",
                    "description": "Path - An optional path used by the application layer of the Channel,\n for example the path component of a HTTP URL."
                },
                "ControlPort": {
                    "type": "integer",
                    "description": "ControlPort - An optional control port for some Channels (eg: WireGuard, Tor)"
                },
                "KeyExchangePort": {
                    "type": "integer",
                    "description": "KeyExchangePort - An optional port used for exchanging keys (eg: WireGuard)"
                },
                "Domains": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Domains - A series of domains that are either to listen for, or to dial to.\n TODO: Document this field according to the capacities of Sliver. Will change."
                },
                "Canaries": {
                    "type": "boolean",
                    "description": "Canaries - If the profile consumer is listening, watch for canary connections."
                },
                "PollTimeout": {
                    "type": "string",
                    "description": "PollTimeout - The maximum amount of times between poll operations for \n protocols like HTTP or DNS. This is different from both beaconing and \n reconnect intervals. Also, and as a consequence, this will not have \n much effect when using a Beacon."
                },
                "ReconnectInterval": {
                    "type": "string",
                    "description": "ReconnectInterval - The amount of wait time after a failed (reverse) \n connection attempt (one side) or bind (other side) attempts. \n This means:\n - An unsuccessful attempt to listen on a port is considered failed.\n - An unsuccessful attempts to dial a destination is considered failed."
                },
                "MaxConnectionErrors": {
                    "type": "integer",
                    "description": "MaxConnectionErrors - The max number of errors that the consumer is allowed \n to sustain when connecting/binding its transport stack. This means:\n - An unsuccessful attempt to listen on a port is considered failed.\n - An unsuccessful attempts to dial a destination is considered failed.\n This value is solely used by the transport using this profile, and is \n not split between other available Transports/Channels on a given host."
                },
                "Persistent": {
                    "type": "boolean",
                    "description": "Persistent - When this profile is used with a C2 Handler job, the job is saved\n and will be restarted in the current context (either on the server, or \n implant if C2 routing is available). Thus, setting this value will only \n have an effect on C2 channel handlers (jobs), and not on C2 channel \n transports (implants). In other words, this setting does NOT mean \"always \n start this transport when the implant starts\"."
                },
                "Active": {
                    "type": "boolean",
                    "description": "Active - Used by internals, will soon be deprecated and removed."
                },
                "CommDisabled": {
                    "type": "boolean",
                    "description": "CommDisabled - Explicitly disallow both parties from establishing an SSH \n multiplexer on top of this Channel, if it's a Session one. This will thus\n render most network tools unavailable (like proxies and UDP forwarders),\n unless the transport stack used by Channel provides its own (eg: WireGuard).\n To be noted also: this will only have an effect on this Profile, and is NOT\n a way to explicitly forbid the Comm code to be compiled in the implant."
                },
                "Interval": {
                    "type": "string",
                    "description": "Interval - The base duration used by a Beacon channel to wait before two \n beacon checkins. This is different from the ReconnectInterval interval field.\n To be noted, the implant will send an updated next-checkin time to the server\n over each beaconing run, and those are available in the console tools."
                },
                "Jitter": {
                    "type": "string",
                    "description": "Jitter - The duration seed to use as a variation over the base Interval \n duration (for time randomness). For example: if a Beacon channel has\n 10s Interval and 5s Jitter, checkins might look like \"12,323s\", \"13,78s\",\n \"7.436s\", and so on."
                },
                "HTTP": {
                    "$ref": "#/definitions/sliverpb.MalleableHTTP",
                    "additionalProperties": true,
                    "description": "HTTP - This contains the MalleableHTTP contains all HTTP-specific \n configuration options, exluding security/encryption parameters. There are \n a few important things to know before editing this Malleable component:\n - There is a SINGLE HTTP profile type for both server and implant sides \n of the channel. Thus, some fields might be used by both ends, while other\n fields will only be used by one of them. All fields in the HTTP section\n have a documentation specifiying which channel side uses them.\n - Because different implants might make use of different but overlaping HTTP\n profiles, the server side of the channel is able to \"merge\" several HTTP\n profiles into one at runtime, so as to be able to serve all implants.\n - If some fields are populated by yourself, and that other required fields \n remain empty, they will be automatically populated with random samples \n out of their default lists/values when the Profile is consumed (compiled \n or used with a handler). Refer to its doc for further info."
                },
                "ProxyURL": {
                    "type": "string",
                    "description": "ProxyURL - A system proxy URL that should be used when either the implant \n is told to so, or if it needs to. In the latter case, the implant has \n different methods: either fetching environment variables, or use of \n specialized proxy libraries, such as github.com/aus/proxyplease."
                },
                "Website": {
                    "type": "string",
                    "description": "Website - When the consumer of this profile is a server, this value is the \n name of the Website that will be used as a frontend (the website code must \n exist and be already loaded into the Sliver server: see `websites` command)."
                },
                "Credentials": {
                    "$ref": "#/definitions/sliverpb.Credentials",
                    "additionalProperties": true,
                    "description": "Credentials - All security elements needed by the profile (certs, keys, \n logins) for all C2 channel transport stacks. There are thus many possible \n configurations in this section, and its own documentation aims to describe \n them exhaustively. Please note, however:\n Most of the Sliver communication security is assured by a thoughtfully set up\n Certificate Infrastructure, which handles the different layers of encryption\n and identity across the Channel stack (transport-layer, core Session/Beacon \n datastream encryption, one-time secrets, etc). \n This is performed automatically when handlers are spawned along with a \n profile, or when transports are compiled into an implant build. Thus, \n if you don't have a REAL need to customize the encryption further (and \n 99.999% of the time, you won't), don't touch this field."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "import \"tagger/tagger.proto\";\n\nMalleable - A Malleable profile contains the entire information a C2 Channel \n needs to use as operating parameters, for all protocols, all session types and \n directions. Some fields are base ones, used by all profiles, regardless of their \n stacks, while others might be specific to some. \n All of these options (base and protocol-specific) can be used by both sides of a \n Channel (ex: bind 127.0.0.1 is used by implant to listen, and server to dial).\n\n Also, a Malleable profile integrates its own Security details, which can vary \n greatly across C2 channels, and also depending on the side of the Channel that \n will use the profile."
        },
        "sliverpb.Credentials": {
            "properties": {
                "CACertPEM": {
                    "type": "string",
                    "description": "CACertPEM - A PEM-encoded Certificate Authority Public Key, which is used \n by channels such as MTLS (and HTTPS in some instances), to verify that the \n identity provided by the remote party is validated by the Sliver server. \n Note that, more than any other fields, you should not have to populate it on \n your own, except from if your specific needs have already made you populate \n ALL other Credentials fields already.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "CertPEM": {
                    "type": "string",
                    "description": "CertPEM - A PEM-encoded Public Key that can have several usages:\n - For channels such as MTLS/HTTPS, is used as a Public Key for TLS wrapping \n if so and mutual authentication is required, this Key will be verified \n against the CACertPEM, thus, if you intend to use those Channels in a \n standard way, you won't have to populate this field on your own: the \n server will take care of it.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "KeyPEM": {
                    "type": "string",
                    "description": "KeyPEM - A PEM-encoded Private Key, which can as well have several usages:\n - For channels such as MTLS/HTTPS, is used as a Private Key for TLS wrapping.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "ServerFingerprint": {
                    "type": "string",
                    "description": "ServerFingerprint - The fingerprint of the Certificate Authority is used \n when the Channel starts the SSH Comm system, which requires authentication. \n Because this value is fixed across all Channels, it will soon be DEPRECATED.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "ControlServerCert": {
                    "type": "string",
                    "description": "ControlServerCert - An optional Public Key used by a control component \n (like a Key Exchange service for WireGuard, or a Tor control port). Most\n channels don't make use of this, but it is here so that you don't have\n to create a new field if you want to add your own (stack-deep) Channel.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "ControlClientKey": {
                    "type": "string",
                    "description": "ControlClientKey - An optional Private Key used for decryption of the\n communications of a control component. This key generally goes hand-in-hand \n with the ControlServerCert field. Thus, if you intend to set either field\n on your own (that is, in an editor and out of the Sliver console context),\n ensure that your fill your related fields correctly.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "TOTPServerSecret": {
                    "type": "string",
                    "description": "TOTPServerSecret - This value is fixed across all Channels, \n thus not relevant, so it will soon be DEPRECATED.",
                    "format": "binary",
                    "binaryEncoding": "base64"
                },
                "LetsEncrypt": {
                    "type": "boolean",
                    "description": "LetsEncrypt - Some application-level protocols like HTTPS (not HTTP) \n may want to connect over \"insecure\" TLS settings, because the server's \n end of the Channel can start a LetsEncrypt certificate infrastructure. \n This might theoretically be applied to any application protocol using TLS, \n as LetsEncrypt is just an side server component handling some certificate \n generation/fetching/matching.\n If true: Starts the LetsEncrypt server on the server end, and connects over\n insecure TLS on the implant's end.\n If false: If the Channel still requires TLS set up, the profile uses either\n user-provided certificates, or certs generated by the Sliver server's PKI."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Credentials - All security elements needed by the profile (certs, keys, logins)\n for all C2 channel transport stacks. \n Most of the Sliver communication security is assured by a thoughtfully set up\n Certificate Infrastructure, which handles the different layers of encryption\n and identity across the Channel stack (transport-layer, core Session/Beacon \n datastream encryption, one-time secrets, etc). \n This is performed automatically when handlers are spawned along with a profile, \n or when transports are compiled into an implant build. Thus, if you don't have \n a REAL need to customize the encryption further (and 99.999% of the time, you \n won't), don't touch this field.\n In the future, a much better integration of the Credentials stored in database \n and those fetched on target hosts is likely, and selecting which credentials or \n logins are used within a profile will be easier through console commands and \n their completions."
        },
        "sliverpb.MalleableHTTP": {
            "properties": {
                "ID": {
                    "type": "string",
                    "description": "ID - You should NOT EVER modify the ID of a Malleable profile: even when \n forking an existing one, copying it, updating it, writing it from scratch: \n the Sliver server will ALWAYS take care of an ID."
                },
                "UserAgent": {
                    "type": "string",
                    "description": "UserAgent - The User Agent value is only used when this Profile is consumed\n by an implant Transport, because the implant is (always) acting as the client.\n If this string is empty, the Server will ALWAYS take care of generating a new\n random one. If this field is already populated, that likely means the server\n already generated one for the profile you are currently editing.\n You can change it however you like: it will override the previous value.\n Important: Implant-side field only"
                },
                "URLParameters": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "URLParameters - The URL parameters are some of those fields that will stay \n the same across all HTTP requests: thus, they are not randomized on a \n per-request basis. Currently the HTTP Channel implementation doesn't make \n use of this field."
                },
                "Headers": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "Headers - The headers of every HTTP request. If this array is empty, the \n Server will automatically use the following headers (there are risks that \n this list is not up-to-date though):\n \n [\"Cache-Control\", \"no-store, no-cache, must-revalidate\"]\n\n Important: Server-side field only"
                },
                "MaxFiles": {
                    "type": "integer",
                    "description": "MaxFiles - The maximum number of complete file names (ex: mysessionfile.txt),\n that are generated for each SAMPLE, sample being passed to the HTTP C2 \n internals for generating a random request URL. Defaults to 8.\n\n Important: Implant-side field only"
                },
                "MinFiles": {
                    "type": "integer",
                    "description": "MinFiles - The minimum number of complete file names (ex: mysessionfile.txt),\n that are generated for each SAMPLE, sample being passed to the HTTP C2 \n internals for generating a random request URL. Defaults to 2.\n\n Important: Implant-side field only"
                },
                "MaxPaths": {
                    "type": "integer",
                    "description": "MaxPaths - The maximum number of paths (eg: \"my/path/to\" in the following URL:\n \"https://example.domain.com/my/path/to/mysessionfile.txt\") that are generated\n for each SAMPLE, sample being passed to the HTTP C2 internals for generating \n a random request URL. Defaults to 8.\n\n Important: Implant-side field only"
                },
                "MinPaths": {
                    "type": "integer",
                    "description": "MinPaths - The minimum number of paths (eg: \"my/path/to\" in the following URL:\n \"https://example.domain.com/my/path/to/mysessionfile.txt\") that are generated\n for each SAMPLE, sample being passed to the HTTP C2 internals for generating \n a random request URL. Defaults to 2.\n\n Important: Implant-side field only"
                },
                "StagerFileExt": {
                    "type": "string",
                    "description": "StagerFileExt - The Stager file extension is consumed by an HTTP server \n consuming this Profile. All incoming connections requesting a URL ending \n with this extension will be served an implant stage.\n\n Default: \".woff\"\n\n Important: Server-side field only"
                },
                "KeyExchangeFileExt": {
                    "type": "string",
                    "description": "KeyExchangeFileExt - Key Exchange file extension. (default .txt) \n Important: Server/Implant field"
                },
                "KeyExchangeFiles": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "KeyExchangeFiles - Filenames for key exchange requests.\n\n Default list: \n \"robots\", \"sample\", \"readme\", \"example\"\n\n Important: Server/Implant field"
                },
                "KeyExchangePaths": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "KeyExchangePaths - URL paths for key exchange requests.\n \n Default list: \n \"static\", \"www\", \"assets\", \"text\", \"docs\", \n \"sample\", \"data\", \"readme\", \"examples\"\n\n Important: Server/Implant field"
                },
                "PollFileExt": {
                    "type": "string",
                    "description": "PollFileExt - Session Polling file extension. For a normal Session/Beacon \n Channel, polling files are the most used ones, because most of the \n underlying stream content passes through them (default: .js)\n\n Important: Server/Implant field"
                },
                "PollFiles": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "PollFiles - Filenames for session polling requests.\n \n Default list: \n \"bootstrap\", \"bootstrap.min\", \"jquery.min\", \"jquery\", \"route\",\n \"app\", \"app.min\", \"array\", \"backbone\", \"script\", \"email\",\n\n Important: Server/Implant field"
                },
                "PollPaths": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "PollPaths - URL paths for session polling requests.\n \n Default list: \n \"js\", \"umd\", \"assets\", \"bundle\", \"bundles\", \"scripts\", \"script\", \n \"javascripts\", \"javascript\", \"jscript\",\n\n Important: Server/Implant field"
                },
                "StartSessionFileExt": {
                    "type": "string",
                    "description": "StartSessionFileExt - File extension for requests to start a new Session.\n This is also used by Beacon channels because as the Malleable.Type \n documentation above explains, the Session type is used by Beacon channels.\n (default .phtml)\n\n Important: Server/Implant field"
                },
                "SessionFileExt": {
                    "type": "string",
                    "description": "SessionFileExt - Session files requests are used when the implant side \n of the channel (the client) wants to write data back to the server. Thus, \n session files are also used a lot, like Poll requests. (default: .php)"
                },
                "SessionFiles": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "SessionFiles - Filenames for session (write data to server) requests.\n\n Default list:\n \"login\", \"signin\", \"api\", \"samples\", \"rpc\", \"index\",\n \"admin\", \"register\", \"sign-up\",\n\n Important: Server/Implant field"
                },
                "SessionPaths": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "SessionPaths - URL paths for session (write data to server) requests.\n\n Default list:\n \"php\", \"api\", \"upload\", \"actions\", \"rest\", \"v1\", \"auth\", \"authenticate\",\n \"oauth\", \"oauth2\", \"oauth2callback\", \"database\", \"db\", \"namespaces\",\n\n Important: Server/Implant field"
                },
                "CloseFileExt": {
                    "type": "string",
                    "description": "CloseFileExt - The file extension used for requests to close the HTTP Channel.\n (default: .png)\n \n Important: Server/Implant field"
                },
                "CloseFiles": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "CloseFiles - Filenames for Session close requests.\n\n Default list: \"favicon\", \"sample\", \"example\",\n\n Important: Server/Implant field"
                },
                "ClosePaths": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "ClosePaths - URL paths for Session close requests.\n\n Default list:\n \"static\", \"www\", \"assets\", \"images\", \"icons\", \"image\", \"icon\", \"png\",\n\n Important: Server/Implant field"
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "MalleableHTTP - An HTTP-specific Channel profile. Important notes:\n - There is a SINGLE HTTP profile type for both server and implant sides \n of the channel. Thus, some fields might be used by both ends, while other\n fields will only be used by one of them. All fields in the HTTP section\n have a documentation specifiying which channel side uses them.\n - Because different implants might make use of different but overlaping HTTP\n profiles, the server side of the channel is able to \"merge\" several HTTP\n profiles into one at runtime, so as to be able to serve all implants.\n - If some fields are populated by yourself, and that other required fields \n remain empty, they will be automatically populated with random samples out \n of their default lists/values when the Profile is consumed (compiled or used \n with a handler)"
        }
    }
}